/**
Copyright 2017, Lecoq Simon (lowlight.fr)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function(global){var _Mathsign=Math.sign,_Mathmin=Math.min,_Mathabs=Math.abs;"undefined"==typeof global.Lowlight&&(global.Lowlight={}),"object"==typeof module&&"object"==typeof module.exports&&(module.exports=global.Lowlight);class Graph{constructor(...vertices){this.vertices=new Map,this.meta={},vertices.length&&this.add(...vertices)}get size(){return this.vertices.size}add(...vertices){return vertices.forEach(vertex=>{this.vertices.has(this)||vertex.graphs.set(this,new Map),this.vertices.has(vertex.id)||this.vertices.set(vertex.id,vertex)}),this}get(id){return this.vertices.get(id)||null}delete(...vertices){return vertices.forEach(vertex=>{vertex.neighbors(this).forEach(neighbor=>neighbor.graphs.get(this)&&neighbor.graphs.get(this).delete(vertex.id)),vertex.graphs.delete(this),this.vertices.delete(vertex.id)}),this}edge(a,b,{ab=1,ba=1}={}){if(!a.graphs.has(this)||!b.graphs.has(this))throw new Error("Vertices must be on the same graph");return isNaN(ab)?a.graphs.get(this).delete(b.id):a.graphs.get(this).set(b.id,ab),isNaN(ba)?b.graphs.get(this).delete(a.id):b.graphs.get(this).set(a.id,ba),this}cost(a,b){return this.adjacent(a,b)?a.graphs.get(this).get(b.id):NaN}adjacent(a,b){return!!b&&a.graphs.get(this).has(b.id)}connected(a,b,bfs=!1){const connectivity=a.graphs.get(this).__connectivity===b.graphs.get(this).__connectivity;if(bfs&&connectivity){let found=!1;for(const stack=[a],visited=new WeakSet([a]),marker=a.graphs.get(this).__connectivity;stack.length;){const vertex=stack.shift(),neighbors=vertex.neighbors(this);for(let neighbor of neighbors){if(neighbor.id===b.id){found=!0;break}visited.has(neighbor)||neighbor.graphs.get(this).__connectivity!==marker||(stack.push(neighbor),visited.add(neighbor))}}return found}return connectivity}connect(){let marker=0;const vertices=[...this.vertices.values()];vertices.forEach(vertex=>vertex.graphs.get(this).__connectivity=NaN);for(let vertex of vertices){if(!isNaN(vertex.graphs.get(this).__connectivity))continue;const stack=[vertex];for(marker++;stack.length;){const cvertex=stack.shift();cvertex.graphs.get(this).__connectivity=marker,cvertex.neighbors(this).forEach(neighbor=>{isNaN(neighbor.graphs.get(this).__connectivity)&&0>stack.indexOf(neighbor)&&stack.push(neighbor)})}}return this}debug(){console.log(`${"ID".padEnd(8)} | ${"Neighbors".padEnd(32)} | Data`);for(let vertex of this.vertices.values())console.log(`${vertex.id.toString().padEnd(8)} | ${vertex.neighbors(this).map(n=>n.id).join(", ").padEnd(32)} | ${JSON.stringify(vertex.data)}`)}}Graph.fromArray=function(array,data={}){const{order="yx",layers=[{}]}=data,X="xy"===order?array.length:array[0].length,Y="xy"===order?array[0].length:array.length,graphs=[],at=(x,y)=>"xy"===order?array[x][y]:array[y][x];for(let layer of layers){const options={...data,...layer},graph=new Graph;graph.meta={...options,X,Y,torus:options.torus},graphs.push(graph);const id=(x,y)=>Graph.fromArray.id(x,y,graph.meta),cost=options.cost||(()=>1),edge=(a,b)=>b?graph.edge(a,b,{ab:cost(a,b),ba:cost(b,a)}):null;for(let x=0;x<X;x++)for(let y=0;y<Y;y++){const data="object"==typeof at(x,y)?at(x,y):{v:at(x,y)},vertex=graph.add(1<graphs.length?graphs[0].get(x,y):new Vertex(id(x,y),{x,y,...data})).get(id(x,y));edge(vertex,graph.get(id(x-1,y))),edge(vertex,graph.get(id(x+1,y))),edge(vertex,graph.get(id(x,y-1))),edge(vertex,graph.get(id(x,y+1)))}if(options.diagonals)for(let x=0;x<X;x++)for(let y=0;y<Y;y++){const vertex=graph.get(id(x,y)),lx=graph.adjacent(vertex,graph.get(id(x-1,y))),rx=graph.adjacent(vertex,graph.get(id(x+1,y))),oy=graph.adjacent(vertex,graph.get(id(x,y-1))),uy=graph.adjacent(vertex,graph.get(id(x,y+1)));null===options.cutting?(lx&&oy&&edge(vertex,graph.get(id(x-1,y-1))),lx&&uy&&edge(vertex,graph.get(id(x-1,y+1))),rx&&oy&&edge(vertex,graph.get(id(x+1,y-1))),rx&&uy&&edge(vertex,graph.get(id(x+1,y+1)))):((lx||oy||options.cutting)&&edge(vertex,graph.get(id(x-1,y-1))),(lx||uy||options.cutting)&&edge(vertex,graph.get(id(x-1,y+1))),(rx||oy||options.cutting)&&edge(vertex,graph.get(id(x+1,y-1))),(rx||uy||options.cutting)&&edge(vertex,graph.get(id(x+1,y+1))))}graph.connect(),graph.get=function(x,y){if(1===arguments.length){if("number"==typeof arguments[0]){const id=arguments[0];return this.vertices.get(id)||null}if("object"==typeof arguments[0]){const node=arguments[0];return this.vertices.get(Graph.fromArray.id(node.data.x,node.data.y,this.meta))||null}}return this.vertices.get(Graph.fromArray.id(x,y,this.meta))||null}}return arguments[1]&&"layers"in arguments[1]?graphs:graphs[0]},Graph.fromArray.id=function(x,y,{X,Y,torus=!1}){return torus?(y+Y)%Y*X+(x+X)%X:0<=x&&x<X&&0<=y&&y<Y?y*X+x:null};class Vertex{constructor(id,data={}){"object"==typeof arguments[0]&&(data=arguments[0],id=data.id),this.id=id,this.graphs=new Map,this.data=data}neighbors(graph){if(!this.graphs.has(graph))return[];const ids=[...this.graphs.get(graph).keys()],neighbors=ids.map(id=>graph.get(id));return neighbors}}class BinaryHeap{constructor(score=node=>+node){this.nodes=[],this.score=score}get size(){return this.nodes.length}add(...nodes){return nodes.forEach(node=>{this.nodes.push(node),this.bubble(this.size-1)}),this}delete(...nodes){return nodes.forEach(node=>{const i=this.nodes.indexOf(node);if(~i){const end=this.nodes.pop();i<this.size&&this.update(this.nodes[i]=end)}}),this}update(...nodes){return nodes.forEach(node=>{const i=this.nodes.indexOf(node);~i?this.bubble(i).sink(i):this.add(node)}),this}pop(){const root=this.top();return this.delete(root),root}top(){return this.nodes[0]||null}bubble(n){var _Mathfloor=Math.floor;for(;0<n;){const m=_Mathfloor((n+1)/2)-1,score=this.score(this.nodes[n]);if(score>=this.score(this.nodes[m]))break;[this.nodes[n],this.nodes[m]]=[this.nodes[m],this.nodes[n]],n=m}return this}sink(n){for(;;){let m=null;const r=2*(n+1),l=r-1,score=this.score(this.nodes[n]);if(l<this.size&&this.score(this.nodes[l])<score&&(m=l),r<this.size&&this.score(this.nodes[r])<(m?this.score(this.nodes[m]):score)&&(m=r),null===m)break;[this.nodes[n],this.nodes[m]]=[this.nodes[m],this.nodes[n]],n=m}return this}*[Symbol.iterator](){return this.nodes}}class ExternalPromise{constructor(){this.solve=()=>null,this.reject=()=>null,this.promise=new Promise((solver,rejecter)=>{this.solve=solver,this.reject=rejecter})}}const Heuristics={manhattan:function(a,b,{multiplier=1,torus=!1,X=0,Y=0}={}){let dx=_Mathabs(b.data.x-a.data.x),dy=_Mathabs(b.data.y-a.data.y);return torus&&(dx=_Mathmin(dx,b.data.x-a.data.x+X,a.data.x-b.data.x+X),dy=_Mathmin(dy,b.data.y-a.data.y+Y,a.data.y-b.data.y+Y)),multiplier*(dx+dy)},diagonal:function(a,b,{multiplier=1,diagonalMultiplier=1.4,torus=!1,X=0,Y=0}={}){let dx=_Mathabs(b.data.x-a.data.x),dy=_Mathabs(b.data.y-a.data.y);return torus&&(dx=_Mathmin(dx,b.data.x-a.data.x+X,a.data.x-b.data.x+X),dy=_Mathmin(dy,b.data.y-a.data.y+Y,a.data.y-b.data.y+Y)),multiplier*(dx+dy)+(diagonalMultiplier-2*multiplier)*_Mathmin(dx,dy)},euclidian:function(a,b,{multiplier=1,torus=!1,X=0,Y=0}={}){var _Mathsqrt=Math.sqrt;let dx=_Mathabs(b.data.x-a.data.x),dy=_Mathabs(b.data.y-a.data.y);return torus&&(dx=_Mathmin(dx,b.data.x-a.data.x+X,a.data.x-b.data.x+X),dy=_Mathmin(dy,b.data.y-a.data.y+Y,a.data.y-b.data.y+Y)),multiplier*_Mathsqrt(dx*dx+dy*dy)}};class Configuration{constructor(map,options={},worker=""){this.raw=[map,options,worker],this.graphs=[],Array.isArray(map)&&(this.graphs=[Graph.fromArray.call(null,map,options)].flat()),this.worker=worker}set worker(url){if(!Configuration.isWorker)return this._worker_events||(this._worker_events=new Map),null!==url&&url.length?void(this._worker=new Worker(url),this._worker.onmessage=({data})=>{const{method,id,output,error}=Configuration.parse(data),promise=this._worker_events.get(id);promise&&(error?promise.reject(error):promise.solve(output))},this.thread({method:"constructor",input:this.raw})):(this._worker&&this._worker.terminate(),void(this._worker=null))}get worker(){return this._worker||null}async thread({method,input}){const promise=new ExternalPromise,id=Math.random().toString(36).substr(2,9);return this._worker_events.set(id,promise),this._worker.postMessage(Configuration.stringify({method,id,input:Array.from(input)})),promise.promise}async path(start,goal,{jps=!1,heuristic=Heuristics.manhattan,fail=!1,layer=0,thread=!1}){if(jps)return this.jps.apply(this,arguments);if(thread&&!Configuration.isWorker){const{path,scores}=await this.thread({method:"path",input:arguments});return{path:path.map(vertex=>this.graphs[layer].get(vertex)),scores}}return new Promise((solve,reject)=>{const open=new BinaryHeap(node=>node.estimated),scores=new Map,graph=this.graphs[layer],heuristics={estimate:heuristic,options:graph.meta};if(start=graph.get(start),goal=graph.get(goal),open.add({vertex:start,estimated:0}),scores.set(start,{score:0,from:null}),graph.connected(start,goal))for(;open.size;){const current=open.pop().vertex;if(current===goal)break;current.neighbors(graph).map(vertex=>{const score=(scores.has(current)?scores.get(current).score:0)+graph.cost(current,vertex);score<(scores.has(vertex)?scores.get(vertex).score:1/0)&&(scores.set(vertex,{score,from:current}),open.update({vertex,estimated:score+heuristics.estimate(vertex,goal,heuristic.options)}))}),open.delete(current)}let path=[];if(scores.has(goal)){let current=goal;for(path.push(goal);null!==(current=scores.get(current).from);)path.push(current);path=path.reverse()}!path.length&&fail?reject("No path found"):solve({path,scores})})}static parse(object){return JSON.parse(object,(key,value)=>{if(/^@function#([\s\S]+)$/.test(value)){if(value=value.match(/^@function#([\s\S]+)$/)[1],/^\((.*?)\)\s*=>\s*{/.test(value))return eval(value);if(/^function\s*\(/.test(value))return eval(`(${value})`);if(/^[_a-zA-Z0-9]+\s*\(/.test(value))return eval(`function ${value}`);if(/^function\s*[_a-zA-Z0-9]+\s*\(/.test(value))return eval(value);throw new Error(`Unsupported scheme of function serialization : ${value}`)}return /^@map#([\s\S]+)$/.test(value)?(value=value.match(/^@map#([\s\S]+)$/)[1],new Map(JSON.parse(value))):value})}static stringify(object){return JSON.stringify(object,(key,value)=>"function"==typeof value?`@function#${value.toString()}`:value instanceof Map?`@map#${JSON.stringify([...value.entries()])}`:value)}static get isWorker(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope}}if(Configuration.JPS=class{constructor(){throw new Error("Cannot instantiate abstract class Configuration.JPS")}static around(graph,vertex,parent){const{x,y}=vertex.data,d={x:_Mathsign(x-parent.data.x),y:_Mathsign(y-parent.data.y)};return{vertex:graph.get(vertex),x:d.x,y:d.y,left:graph.get({data:{x:x-1,y}}),right:graph.get({data:{x:x+1,y}}),up:graph.get({data:{x,y:y-1}}),down:graph.get({data:{x,y:y+1}}),next:{x:{vertex:graph.get({data:{x:x+d.x,y}}),up:graph.get({data:{x:x+d.x,y:y-1}}),down:graph.get({data:{x:x+d.x,y:y+1}}),previous:{y:{vertex:graph.get({data:{x:x+d.x,y:y-d.y}})}}},y:{vertex:graph.get({data:{x,y:y+d.y}}),left:graph.get({data:{x:x-1,y:y+d.y}}),right:graph.get({data:{x:x+1,y:y+d.y}}),previous:{x:{vertex:graph.get({data:{x:x-d.x,y:y+d.y}})}}},vertex:graph.get({data:{x:x+d.x,y:y+d.y}})},previous:{x:{vertex:graph.get({data:{x:x-d.x,y}}),up:graph.get({data:{x:x-d.x,y:y-1}}),down:graph.get({data:{x:x-d.x,y:y+1}}),next:{y:{vertex:graph.get({data:{x:x-d.x,y:y+d.y}})}}},y:{vertex:graph.get({data:{x,y:y-d.y}}),left:graph.get({data:{x:x-1,y:y-d.y}}),right:graph.get({data:{x:x+1,y:y-d.y}}),next:{x:{vertex:graph.get({data:{x:x+d.x,y:y-d.y}})}}},vertex:graph.get({data:{x:x-d.x,y:y-d.y}})}}}static neighborhood(graph,scores,vertex){const neighbors=new Set,parent=scores.get(vertex).from||null;if(null===parent)vertex.neighbors(graph).forEach(neighbor=>neighbors.add(neighbor));else{const d=Configuration.JPS.around(graph,vertex,parent);if(d.x&&d.y){const nx=graph.adjacent(d.vertex,d.next.x.vertex),ny=graph.adjacent(d.vertex,d.next.y.vertex);(nx||ny)&&d.next.vertex&&neighbors.add(d.next.vertex),nx&&(d.next.x.vertex&&neighbors.add(d.next.x.vertex),!graph.adjacent(d.vertex,d.previous.y.vertex)&&d.next.x.previous.y.vertex&&neighbors.add(d.next.x.previous.y.vertex)),ny&&(d.next.y.vertex&&neighbors.add(d.next.y.vertex),!graph.adjacent(d.vertex,d.previous.x.vertex)&&d.next.y.previous.x.vertex&&neighbors.add(d.next.y.previous.x.vertex))}else graph.adjacent(d.vertex,d.next.vertex)&&(d.next.vertex&&neighbors.add(d.next.vertex),d.x?(!graph.adjacent(d.vertex,d.up)&&d.next.x.up&&neighbors.add(d.next.x.up),!graph.adjacent(d.vertex,d.down)&&d.next.x.down&&neighbors.add(d.next.x.down)):d.y&&(!graph.adjacent(d.vertex,d.left)&&d.next.y.left&&neighbors.add(d.next.y.left),!graph.adjacent(d.vertex,d.right)&&d.next.y.right&&neighbors.add(d.next.y.right)))}return[...neighbors]}static jump(graph,scores,goal,vertex,parent){for(;;){if(!graph.adjacent(parent,vertex))return null;if(vertex.data.x===goal.data.x&&vertex.data.y===goal.data.y)return vertex;const d=Configuration.JPS.around(graph,vertex,parent);if(d.x&&d.y){if(!graph.adjacent(d.vertex,d.previous.x.vertex)&&graph.adjacent(d.vertex,d.previous.x.next.y.vertex)||!graph.adjacent(d.vertex,d.previous.y.vertex)&&graph.adjacent(d.vertex,d.previous.y.next.x.vertex))return vertex;const jump=(a,b)=>Configuration.JPS.jump(graph,scores,goal,a,b);if(null!==jump(d.next.x.vertex,d.vertex)||null!==jump(d.next.y.vertex,d.vertex))return vertex}else if(d.x){if(!graph.adjacent(d.vertex,d.up)&&graph.adjacent(d.vertex,d.next.x.up)||!graph.adjacent(d.vertex,d.down)&&graph.adjacent(d.vertex,d.next.x.down))return vertex;}else if(d.y&&(!graph.adjacent(d.vertex,d.left)&&graph.adjacent(d.vertex,d.next.y.left)||!graph.adjacent(d.vertex,d.right)&&graph.adjacent(d.vertex,d.next.y.right)))return vertex;parent=d.vertex,vertex=d.next.vertex}return null}static cost(graph,current,jumped){let cost=0,next=null;for(const d={x:_Mathsign(jumped.data.x-current.data.x),y:_Mathsign(jumped.data.y-current.data.y)};current.data.x!==jumped.data.x&&current.data.y!==jumped.data.y||null===next;)next=graph.get({data:{x:current.data.x+d.x,y:current.data.y+d.y}}),cost+=graph.cost(current,next),current=next;return cost}},Configuration.prototype.jps=function(start,goal,{heuristic=Heuristics.manhattan,fail=!1,layer=0}){return new Promise((solve,reject)=>{const open=new BinaryHeap(node=>node.estimated),scores=new Map,graph=this.graphs[layer],heuristics={estimate:heuristic,options:graph.meta};if(graph.meta.torus)throw new Error("JPS does not support torus map for now");let jumped=null;start=graph.get(start),goal=graph.get(goal),open.add({vertex:start,estimated:0}),scores.set(start,{score:0,from:null});const neighborhood=vertex=>Configuration.JPS.neighborhood(graph,scores,vertex),jump=(vertex,parent)=>Configuration.JPS.jump(graph,scores,goal,vertex,parent),cost=(current,jumped)=>Configuration.JPS.cost(graph,current,jumped);if(graph.connected(start,goal))for(;open.size;){const current=open.pop().vertex;if(current.data.x===goal.data.x&&current.data.y===goal.data.y)break;neighborhood(current).map(vertex=>{if(null!==(jumped=jump(vertex,current))){const score=(scores.has(current)?scores.get(current).score:0)+cost(current,jumped);score<(scores.has(jumped)?scores.get(jumped).score:1/0)&&(scores.set(jumped,{score,from:current,jumped:!0}),open.update({vertex:jumped,estimated:score+heuristics.estimate(jumped,goal,heuristics.options)}))}}),open.delete(current)}let path=[];if(scores.has(goal)){let current=goal;for(;current.data.x!=start.data.x||current.data.y!=start.data.y;)for(const parent=scores.get(current).from;current.data.x!=parent.data.x||current.data.y!=parent.data.y;)path.push(current),current=graph.get({data:{x:current.data.x+_Mathsign(parent.data.x-current.data.x),y:current.data.y+_Mathsign(parent.data.y-current.data.y)}});path.push(current),path.reverse()}!path.length&&fail?reject("No path found"):solve({path,scores})})},Configuration.isWorker){let instance;onmessage=async function({data}){const{method,id,input}=Configuration.parse(data);switch(method){case"constructor":try{return instance=new Configuration(...input),postMessage(Configuration.stringify({method,id,output:!0,error:null}))}catch(error){return postMessage(Configuration.stringify({method,id,output:null,error}))}case"path":try{const output=await instance.path(...input);return postMessage(Configuration.stringify({method,id,output,error:null}))}catch(error){return postMessage(Configuration.stringify({method,id,output:null,error}))}}}}global.Lowlight.Astar={Graph,Vertex,BinaryHeap,Heuristics,Configuration}})("undefined"==typeof window?this:window);
